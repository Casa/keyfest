Stacie (00:06):
My name is Stacie Waleyko. I've been with Casa for about two years now, working on our backend systems. Prior to Bitcoin, I spent a few years in the enterprise blockchain space. And before that I did some time in the ad tech industry. I'm very excited in Bitcoin education and making sure it's a technology that's accessible to everyone. I'm just so happy to be here and wanted to thank you all again for joining us. 

Ron: My name is Ron Stoner. I joined the Casa team last year as the head of security, and I've worked a variety of positions in the cryptocurrency industry. I also organize and speak at the Devcon blockchain village. I was the the curator for the cryptocurrency security standard auditor exam, and I also sit on that committee for that standard. I love all things security and Bitcoin. And also thank you all for joining us.

Stacie (02:47):
Let's get started by reviewing some cryptography basics.

Stacie (02:54):
We hear the term keys a lot when we talk about Bitcoin, especially when we're dealing with self custody. To start, I want to answer the most basic question. What are cryptographic keys? And at a high level, a key is just a random string of bits. When we look at one in human readable format, it looks like this long line of letters, and numbers. The longer and more random these letters and numbers are, the harder it is to crack. Keys are the building blocks used to perform a number of important cryptographic operations like encryption, decryption, and message signing. Most people are familiar with encryption. We have examples of this that go all the way back to ancient times. There's something called the Caesar cipher that was used to protect military communications where the method of encryption was each letter in the message was shifted by three positions in the alphabet. A would get encrypted to D and then D would map back to A upon decryption. Another way we can use keys is for signing messages. This is really cool because it allows for the creation of digital signatures that can be used the same way regular signatures are used in the real world. They're used to prove the authenticity of a message, check that the message hasn't been tampered with during transit and ensure non-repudiation from the signers part. Let's go ahead and take a look at the two main key types.

Stacie (04:27):
There are two types of commonly used cryptographic systems: symmetric and asymmetric. With symmetric you've only got one key. This key can be used to encrypt or decrypt as well as create and verify your digital signatures. Examples of this would be passwords and shared secrets. We use this kind of stuff all the time.

Stacie (04:50):
Next we have asymmetric. This is when you have separate keys for your cryptographic operations. This is often known as public key cryptography, and as you may have guessed from the title of this workshop, it's what Bitcoin uses. The two types of keys are your private key and your public key. As you can tell by its name, private keys are the ones you keep secret. It's really important no one else knows your private key because it's the one you use to create your digital signatures and decrypt data. If someone else gets it, they can start forging your signature or decrypting messages that are really meant for your eyes only. The other kind of key is the public key. This is the one that you share. Others use it to verify your digital signature or to encrypt messages that they want to send specifically to you. It's very easy to go from a private key to a public key, but nearly impossible to go the other way, and that's why it's safe to share your public key. You can't derive the private key from it. Because of the way these two keys interact, public key cryptography is often considered a really good way of expressing digital identity. It's the foundation for a lot of the online identity applications that we have today.

Stacie (06:12):
One more piece of cryptography 101 we really need to cover is hashing. Hashing is when you use a one-way function to create a digital fingerprint of a piece of data. The output is a fixed size, depending on the specific kind of hash function you use. It's deterministic, which means that you can hash the same message over and over again and you'll always get the same result. To illustrate this, I hashed the phrase "There will only ever be 21 million Bitcoin". I used a website that I just typed into Google, and then to verify it, I also used this command on my computer. And as you can see, both resulted in the same hash, which is awesome. It illustrates that this hash function is deterministic. It's always going to produce the same result and as a kind of bonus, it's unlikely either tool is lying to me because they both match up. So even if hash functions seem like this sparkly black box, the cool thing is we still have a lot of tools at our disposal to create and verify them.

Ron (07:23):
One of the other concepts we want to touch on today that people have heard the term, but I don't know that they can necessarily explain it. I always ask people, have you heard of a digital signature? And they say yes. And I ask them, can you explain to me what's really going on when you do that? And they kind of hum and haw or say no. So what's really going on when we're talking about digital signatures is we're proving that a message or a document was not tampered with. We're validating it, we're verifying. We're not trusting. And what we do, the way this works is we take the contents. That could be an email. That could be a file. It could be a message. And we hash them using the hashing concept that Stacie just talked about. That hash is then encrypted with the sender's private key.

Ron (08:06):
So part of the key pair that we're talking about today, the content and the encrypted hash are then bundled up together and that's sent off to the recipient. Now the recipient receives that, and they make their own hash of the content. They decrypt the sender hash using the public key -- the other side of that key pair. And then they compare the two hashes. So if the original hash equals the recipient's hash, you know that the document wasn't modified in transit, none of the bits or bytes were modified. Nobody's doing anything with malicious intent. So at its very core, that's essentially what digital signatures are doing.

Ron (08:43):
When we talk about digital signatures, encryption and hashing, there are some standards and some terms that you guys may have heard out there in the industry. The data encryption standard or DES was the standard in the seventies, and it was symmetric, but no one really uses it anymore because it only encrypted 56 bits of data at a time. That made it really easy to hack. So even though nobody really uses it today it really did create the foundation in that layer for the more secure encryption methods that we use today.

Ron (09:15):
AES is one that's kind of an industry standard out there. It's one of the most secure and commonly used encryption methods. Instead of doing individual bits of data, it's encrypting blocks and processing that. If you see a number after AES like 128 or 256, what that's indicating is that's indicating the block size. AES uses multiple rounds of encryption. It has a number of mathematical steps with substitution and transposition, mixing in plain text and other methodologies. But it's one that's very important to highlight that's out there being used today.

Ron (09:51):
RSA is another one that's popular, but it's more on the asymmetric side. And this is talking about verifying large prime numbers is how RSA really works. It's great for communication and it's another one that people should be aware of.

Ron (10:06):
And then the last one we list here is SHA, which stands for the secure hash algorithm. And this deals with the hashing concept we talked about. SHA is great for taking information and hashing it and doing that one way function and SHA is great for doing it in a secure manner. You may have seen SHA-1, which was used in SSL certificates, but was deprecated in January 2016 because it wasn't secure enough. So when we're talking about Bitcoin, Bitcoin actually uses SHA 256. So a more secure version of that.

Ron (10:38):
Now that we've learned a little bit about encryption, digital signatures, hashing, and some of the popular terms that are out there, let's jump into the specifics on how Bitcoin really uses these concepts and brings them together. When we are sending Bitcoin, when we're doing transactions, what we're really doing is we're signing things. We're digitally signing them with our private keys. Bitcoin uses a digital signing algorithm called ECDSA. It's elliptic curve cryptography, and the word curves is in there because what we are really doing is we're really dealing with curves here, as you can see on the chart. At a general level, you have a mathematical equation that plots the curve on a graph. We pick a random point on that curve and that's considered our point of origin. Then we generate a random number, the private key. By doing a math equation, using that random number in that point of origin, we can generate a second point on the curve and that point becomes our public key.

Ron (11:37):
And now we've generated a public-private key pair that corresponds to each other. So when you see things like public key and private key, they're very much associated, and this is how it's being done on the backend. It's important to note that ECDSA does not encrypt. We're not hiding data, we're signing data and validating it. Like RSA, it uses the discrete log problem, so there's a lot of math and cryptography on the backend. It has the same level of security as RSA, but it's got the shorter key length. So what this does is less bandwidth storage and processing power. For longer keys, it's considerably longer to brute force. So we're getting a lot of security benefits there.

Ron (12:22):
But don't get too attached to ECDSA because the Taproot, Bitcoin Improvement Proposal (BIP) 341 upgrade is going to include Schnorr signatures. I've put a picture here of Claus-Peter Schnorr just because we really should be highlighting the cryptographers and the giants whose shoulders we're standing on today. Schnorr signatures are going to be great because they include secure proofs. They have a smaller footprint. Instead of 71 bytes, we're getting 64 byte signatures, so we're saving space on chain. There are less assumptions about the discrete log problem so it's easier to implement and process the system. This was patented up until 2008 and Bitcoin is actually going to be one of the first major open source implementations that's going to be using this. The big benefit is instead of doing single signatures like we do with ECDSA, we're going to be able to aggregate all those signatures and put it on chain. So there are going to be more privacy benefits. There's going to be savings. It's a great piece of technology that's right around the corner.

Stacie (13:33):
Everything we're talking about feeds into the question, what does it mean to actually own a Bitcoin? Bitcoin addresses correspond to how you want to be able to spend your Bitcoin. That's either going to be a public key, which is the simplest scenario. This is often referred to as P2PKH, P2WPK, if anyone has heard those terms before. Or, for more complex spending conditions, we're going to be using a script. A multisig script actually has all the public keys of the devices involved in the multisig scheme. So, when you want to spend the Bitcoin, you actually use the matching private key (or keys if you're using more than one key pair) to sign a message. You're basically signing a message that says, "I am transferring ownership of this Bitcoin to someone else's address."

Stacie (14:26):
Then you go ahead and broadcast the signature. When it gets to another node, that node is going to check that the message was signed with the correct private key. This is basic digital signature verification. The nice thing is that while a digital signature is computationally expensive to make, it's very cheap to verify. Once the node confirms that the signature is valid, your transaction is accepted by the network. It's going to go ahead and propagate it. But if the signature, which is oftentimes referred to as the witness, is invalid, let's say you use the wrong private key, or maybe you don't have the private key and you made something up, or maybe you're using multisig and you're supposed to sign with two keys and you only signed with one. All of these scenarios are going to result in the transaction being rejected by the network. Nodes will not forward any information that they have not verified for themselves.

Stacie (15:23):
Owning Bitcoin comes down to having the private key or keys that correspond to the address with the funds. Proper Bitcoin ownership is really about responsible private key management. Private keys can be generated and live in lots of different places. They can live in hardware wallets like a Trezor or a Ledger. These are cool because these devices are dedicated to this one single purpose. They can live in your phone's secure element if you're using a mobile wallet. They can live on a piece of paper, which we call a paper wallet. They can even live in your brain, which we call brain wallets, and that's when you memorize it. A really cool concept, but really insecure, so we do not recommend it. If you're familiar with seed phrases, they're basically private keys, which is why it's so, so important that they don't fall into the wrong hands.

Stacie (16:18):
All of this goes to that famous phrase. We just celebrated Proof Of Keys, "Not your keys, not your coins." This is why it's so popular. If you don't have the private keys to actually sign off on the addresses where your funds are held, you don't actually have any control over them. Holding your own keys is often seen as the first major step to taking advantage of the freedom and the self sovereignty that Bitcoin offers. But, I'd be remiss not to acknowledge that this comes with its own set of concerns, mainly around security. Are your keys secure against attackers? What about accidental loss? What if you make a mistake? There's really a lot to think about here, but that's not a conversation for this workshop. If anyone is interested, Jameson is doing a privacy and security workshop on Thursday with Matt Odell and Michael Haley. That's probably going to be a great segue into some of this stuff.

Stacie (17:14):
Now, Ron's going to take us on a demo.

Ron (17:22):
Cool. Let me go ahead and bring up my console.

Ron (17:35):
So we should see a console here. Let me go ahead and increase the size for you all. We've created a Python script just for demo purposes. What I will highlight is that this script should never be used for any production reasons. It shouldn't be used to generate keys that are going to hold any value. This doesn't use any hardware wallets or multiple sources of entropy. This is just to display a couple of the concepts that we've listed here today.

Ron (17:58):
The first thing we want to display is that brain wallet Stacie was talking about. We can generate an insecure brain wallet key set. The way brain wallets worked was they took something that was in your brain, a word, a passphrase, a lyric, movie quotes, something like that, even your email address, and that was essentially your private key. It was great for usability, but it was horrible for security because if we put the word Satoshi in here, we can see that it inputs it and it basically runs it through one round of SHA 256 and then generates a key pair based off of it. From that key pair, based off of some magic math and some things that we'll talk about in this demonstration, we can get an address out of it. The thing that I wanted to demonstrate here is that these methods aren't very secure, but we can use them to generate the key pairs that we're talking about.

Ron (18:48):
The more secure method would be to generate an ECDSA key set using that elliptic curve cryptography. In order to do this, we need to generate private key material. That private key material could be words, and things like that. But, when we're doing ECDSA, and we want to do it in a more secure fashion, we should be using randomized hex values. There is a hex value on the Internet that we can use, but it looks like I don't have it. Well, regardless, if you ended up putting a bunch of hex information in here, it should be 64 bytes or 32 characters, we can generate keys off of that as well, and we can get the pub key. We can go through all of the hashing mechanisms that we talked about earlier, and then eventually we get to a Bitcoin address. The script is also good because if you press enter for random, it's going to use the system entropy, os.urandom, to grab some random entropy and generate a key set off of that. When we're generating keys on things like hardware wallets, that's what it's doing. It's using multiple sources of entropy from the system and other mechanisms to get the initial string that's generating the private key, that gets the public key, that then gets the address. If we do another random one here, we can see that we're getting different addresses each time using random system entropy.

Ron (20:32):
If you guys wanted to try this yourself, you can actually do this using Bitcoin nodes. So if you have a Bitcoin node that sync'd to the network, you can use the Bitcoin CLI to generate keys, as well as dump that private key information, if you want to. Here are the commands for that if you guys want to try this. The other thing you can do is you can take some of those brain wallets that are out there on websites, because there are websites that categorize that stuff and list those things as being not secure, as being compromised, and see if you generate the same key pairs. You can actually walk through the Python script and look at each of the individual functions as to how it's taking that stuff, how it's hashing it, and how it's generating the key pairs, and ultimately the address. I think Stacie is going to touch on that right now as to what's really going on when it's doing all of those operations.

Stacie (21:27):
Yeah. Thanks, Ron. That was a great demo. So I've been watching the chat and checking out your questions and I'm seeing a lot of questions about having multiple keys and derivation paths. Someone asked a question about SHA-256. This next set of slides is going to go into the nitty-gritty. Hopefully we'll be able to answer a lot of these questions along the way.

Stacie (21:51):
So now that we've learned about keys and we've actually seen key and address generation, let's walk through how to go from a key pair to an address. I'm going to take you through the most basic example, which is making an address from a single public key. This is referred to as P2PKH, pay to public key hash (if anyone is familiar with those terms). I will be using the diagram on the left as a guide. It is from a really fantastic book called Mastering Bitcoin by Andreas Antonopoulos. It's one of the OG, "teach me about Bitcoin" books. If you haven't read it, I highly recommend it. Note that it's a little bit dated. It doesn't cover a newer feature called SegWit, but I still really like the diagram because it covers all the basics.

Stacie (22:41):
Earlier we touched upon hashing and that was important because addresses are basically hashes. In this example, the input we're going to use is a public key, but for more complex spending conditions, such as multisig or something called wrapped SegWit, you're going to be using a script as your input. Now, the reason why we hash is because public keys can be really long. A compressed ECDSA public key is 33 bytes, which comes out to 44 characters in base64 encoding. That's actually still pretty big, and we're just talking about the simplest kind of address with one public key. It's not a multisig script with multiple things in it. It's just the smallest thing we can make. In addition to that, there are actually a number of really good reasons to use a character set smaller than base64.

Stacie (23:31):
Okay, let's go to this diagram, take a look at that blue box on the top. This is where we are now. We have our input and we're going to go ahead and compute the hash. So we're going to move over to these green boxes. In this example, they use the HASH-160 function, which is actually made up of these two green boxes. It's a double hash where the first step is to compute the SHA-256 hash, then the second step is to compute the RIPEMD-160 hash. Now the exact details of this hashing step may slightly vary depending on what kind of address you are creating. For example, SegWit P2WSH uses only a single SHA-256 hash. Either way, you end up with a hash of a fixed size.

Stacie (24:16):
Note that at this point, because hash functions are one way, we actually can't go backwards and derive the public key from the hash. Because of this, when you're ready to spend, you're going to have to provide the original input. In our case, it's a public key. You do this so that nodes can validate the address. For those familiar with multisig, you've probably heard that you need to back up the public keys of all devices in the setup, and this is why. You need to be able to recreate the multisig redeem script that the address was derived from because you can't go backwards.

Stacie (24:53):
Let's go back to the diagram. We are currently on the second blue box. We have a hash. The last thing we need to do is convert it to a more compact format and add a little bit of human readable data and some error checking. In our example, we're going to use base58 encoding, which is kind of like base64, but without a number of commonly misinterpreted characters like lowercase L and capital I. But, if you're using SegWit, you're going to be converting to something called bech32, which is kind of like base32, it is case insensitive. But, the character set has been specifically chosen to optimize for their error detection algorithm.

Stacie (25:35):
Final step is to add in a small human readable prefix at the beginning, which I have some examples of on the next slide, as well as an error checking mechanism called the checksum. A checksum is an additional four to six bytes at the end, which help protect against mistyped addresses. This is really great. It can actually detect if you're manually copying an address and you get a character wrong, which is nice because if it didn't do that, it would probably let you send funds into the ether to an address that no one has the private keys for. That's actually what it means when we say coins are lost.

Stacie (26:19):
This is all I'm going to say about address derivation. I know this slide is a little bit long. This stuff can be complex depending on what you're trying to do. On the next slide, we have an example of a bunch of different address types that you can check out.

Stacie (26:38):
So in that previous example, we only walked through one kind of address and it's the one on the top, but there are actually many more. As you can see in that middle column, all addresses actually begin with a human readable portion. Right now you can tell the address type from it and from a privacy perspective, this is not that great. You know, if an address begins with 1, it's going to a single public key. You know that's not a multisig address. If it's going to 3, you know it's going to a script and the chances of it being multisig are a little bit higher. After spending, you can verify by looking at the data on the blockchain. If you go down to the second box, we also have prefixes for testnet, which is great. These can be m, n, or 2, which is just really nice to be able to differentiate between mainnet and testnet. If you get down to the bottom, you'll see bc1 and tb1. These are prefixes for native SegWit. We'll probably continue to see these and hopefully, see more of them in the future but I think a lot of wallets are still playing catch up with this.

Ron (27:51):
Some of you may have seen vanity addresses where you can put your name in the beginning of the address or things like that. People have asked me, why can't it just be my name to start or my email address? This right here is why, because they need to be prefixed based off of the conditions in the system, and the cryptography, and all the math and hashing functions that go into address generation. So while it may seem simple to ask "can't you just make it my email address?" Well, no we can't, and here's why.

Stacie (28:16):
Yeah, definitely. I love that example. I wish we could do a whole thing on vanity addresses.

Stacie (28:25):
Lastly, I want to touch on enhancements to how addresses and keys are structured in wallets because it's a little more complicated than just having a single public-private key pair. This is going to be the slide if you're interested in derivation paths or if you're interested in generating more than one key pair for your wallet. This is the stuff that's going to be of interest to you. For privacy and security reasons, address reuse is strongly discouraged in Bitcoin, but this means that every time you want to generate a new address, you have to make a new pair of public and private keys. In the early days, the Bitcoin core client would generate a hundred random key pairs on startup and create more as needed. That was great. You never had to reuse addresses, but the problem was there was nothing tying these keys together.

Stacie (29:18):
So, if you wanted to make a backup, you needed to back up every single pair of keys. Luckily in 2012, a proposal called BIP-32 was made for something called hierarchical, deterministic wallets. These are wallets that allow you to derive many sets of keys from a single random number called a seed. It turns out there are a ton of advantages to this structure. I have a diagram of it on the right. This also comes from Mastering Bitcoin. One of the most important things is now you can deterministically recreate wallets from a single seed. So, you no longer have to back up every single pair of keys you've ever generated. You just need that one seed. Shortly afterwards, another proposal called BIP-39 was made to map seeds to a set of mnemonic words. And this is how you get those seed phrases that you're probably familiar with if you've ever set up a hardware wallet.

Stacie (30:19):
Okay, now I'm going to do a quick demo. You should be able to see my screen. Awesome. This is a website called iancoleman.io. It's really awesome. We're going to walk through some of the BIP-32 and BIP-39 functionality that they have. Before I get into it, everyone promise me, you'll never use this for real funds. There are so many ways that it can go wrong and Ron's actually going to go into some secure key generation points after this. If you just use a website from the internet like this to generate your private keys or do anything with your private keys, like expose them, you're not going to have a good time.

Stacie (31:12):
Over here they have a demo where you can generate a random mnemonic phrase. I'm going to go ahead and do that. Look, there it is. Nice. Actually, if you want to take a screenshot and write these words in later, you're going to be able to derive all the exact same information that I am right now, whether or not you use the Ian Coleman tool, or you use a script that you write yourself, or someone else's tool, because it's all deterministic. As we mentioned earlier, the seed phrase is just the human readable version. This BIP-39 seed over here is what it looks like to a computer in computer language. We also have the BIP-32 root key. This is basically at the root of that HD wallet tree that we saw in the previous slide.

Stacie (32:05):
Now we're going to scroll down and get into derivation paths. I'm going to work with BIP-32, that's really the easiest one to talk about. BIP-44, 49, 84, 141, these are all standards that get into specific definitions of how you use derivation paths. A derivation path looks like this, and it corresponds to a leaf in the tree. So if I scroll down -- I'm just going to look at m/0 for now -- If I scroll down, I actually can see every single address, every single public key, and every single private key that would be generated for each leaf on the tree. You can go as far as you want here. If you go to m/0/5/20 and it'll take you to a different branch in the tree. There are a number of attacks that have been mentioned in the past where an attacker will basically trick you into sending funds to yourself, but to some crazy derivation path, obviously it's gonna be crazier than this, that you can never find. That's why they're called ransom attacks. You have to give them the money before they tell you the derivation path. This is what's going on for all that stuff. It's a really awesome tool, especially for development, especially for learning. Check it out. If you have time, there's also some other cool tools that he has. That's how BIP-32 and BIP-39 kind of work in the real world.

Ron (33:55):
Cool. Great demo, Stacie. Thank you. I'm a security guy and I always need to give my security spiel and caveat this with we're generating keys. These keys are being used to either protect sensitive information or protect digital value of some sort. So when we're doing it, there are some security considerations that we need to really think about to do this properly. Number one, whom is generating your key pairs. Is it you? Or is it somebody, you know, that's doing it and then handing them to you? How do you know they didn't keep a backup or they don't have a file called keys.txt on their desktop? If they do, I don't recommend that that person generate your keys. It should be somebody knowledgeable enough with the system and the processes that are taking place. They should have a level of familiarity and comfortability with it because there are little tiny gotchas and caveats in digital signatures. If they don't know that the K value needs to be randomized, you're in for a bad time. Bad things are going to happen and you're going lose money or value at some point.

Ron (34:57):
The second thing to consider is your environment. This can go pretty deep. It starts with things like don't do it in the coffee shop. Watch out for shoulder surfers, people behind you watching your screen or taking a picture if you get up and walk away. Do you have your key material on the screen, in your laptop all the time? It also goes a little bit further. When I generate keys and things like that, I actually sweep the room of all electronics. We all have watches, smartwatches. We have microphones and cameras in our pockets all the time. Even our smart TVs have cameras and microphones where they could potentially be listening. So if you're generating keys and you're reading out my private key, or my seed word is correct-horse-battery-staple, somebody could be listening to that. Be aware of the environment that you're generating in. It should be done on an offline or air gapped machine or hardware wallet. The reason for this is they're not connected to the internet. They can't get malware through a network connection. That doesn't mean they can't be hacked. It's never 100% in security, but we are taking the steps to mitigate and make those attackers jump through multiple hoops to be able to compromise our key material.

Ron (36:04):
Proper entropy is a big one. You saw during our demo an insecure brain wallet using some entropy from up here. Then we also showed a more secure version using ECDSA, and some entropy from the urandom operating system. In order to do this, you would really want to use a TRNG, a true random number generator, or a deterministic random bit generator. These are things that measure electrical impulses. They can do entropy in a variety of ways that have been statistically tested against some of these standards and things here at the bottom.

Ron (36:41):
We're not all mathematicians. We're not all cryptographers. We don't have the resources to break down all these devices and audit every single piece of code and test them. So at some point, your verification does have to become trust unless you're going through that whole end to end process. You can put your trust in some of these standards and institutions like NIST and the DIEHARD statistical test. What these tests do is they are standards and they test some of these devices and these entropy devices to make sure they are truly random and you're not going to have an issue where we find out that certain versions of Android didn't include a big enough entropy pool and as a result, a blockchain wallet mobile app is now losing user funds because they're generating the same key pairs.

Ron (37:28):
There's a lot to think about with this. You can even go offline and analog and do this with dice and cards, and a copy of the script that Stacie showed you on an airgapped computer that's been audited. If it's something that you're not comfortable with, find an expert that is, or find a resource that can help you out with this process. We're here for you guys. This is stuff that we love to talk about and as you can see in our presentation today, there's a lot that really goes into this, but if you can consume the information and jump into it, you can really do it correctly

Ron (38:02):
To summarize our workshop here today, public keys are being used to create addresses. Those private keys, which correspond to the public keys are used to create digital signatures. Digital signatures are used to spend and move Bitcoin. At the root of every Bitcoin wallet, we have a seed, which is essentially a private key. That private key is really the key to the kingdom. It's highly sensitive and it should be protected. Now we're at a point where those seed phrases are --- we have human readable versions of. So, we have a system that's processing and crunching all of this technical math and cryptography, but at the end of it, we've got a human readable version of our private key.

Ron (38:46):
We've provided some additional resources here for you all as well. I saw in the chat, somebody was asking about the Mastering Bitcoin book. That's by Andreas Antonopoulos. You can find that linked here. It's an amazing resource for people that are trying to learn more about this. We've listed some other links here because a lot of these concepts that we've talked about today go very, very deep. If you're a math person or you're a cryptographer, or if you're just somebody that wants this information for their own knowledge because you're interested in it, here are some resources you can jump into and dive in further.

Ron (39:20):
We want to thank everybody for attending our workshop here today. You guys are awesome. We've seen a lot of questions here in the chat, so let's go ahead and bring it up and see what the the first one is. "What are your thoughts regarding keeping your keys truly private when it comes to acquiring Bitcoin? More and more on-ramps are requiring KYC and other identifiable information. What are your thoughts on how one can mitigate this potential theft of privacy, particularly when more people are onboarding in the crypto space?" This is a tough question. There are a lot of businesses and institutions where one can acquire bitcoin. The things that I'm always interested in when that happens is are they generating the keys? Are they custodial or not? Are they generating and managing the keys on my behalf? Because if they are, I'm not really owning the coin. Or, is it something where I bring my own hardware wallet to that site or service? With KYC and regulation, unfortunately regulation hampers industry and innovation, and it's making it harder for some businesses to compete. So if you're in the United States, for example, or you're trying to do business with US entities, a lot of those are being forced into KYC funnels due to different regulations and things that are out there.

Ron (40:33):
I don't have a good way to recommend that you subvert those controls, because I'm not going to advocate for that. But, what I would advocate for is maintaining your own personal privacy and security. If you can find sites and services that don't require all of that information, or allow you to use things like a pseudonym, or a burner email address, or a VoIP phone numbers, I would recommend using those sites and services. Number one, to protect your information but number two, it's future-proofing a little bit, because we've seen things with database leaks and recent hacks where customer information has been released as a result of that. If you can take the steps to protect your identity and protect your information before you even need to transact with some of these sites and services, I think that that goes miles for your own personal security and protection.

Stacie (41:20):
Yeah, Ron, I think that was a great answer. I'll just add that while KYC, bitcoin is the easiest to acquire, it's not the only way to acquire bitcoin. There is peer to peer trading. You can work for bitcoin. You can, if you have a business, say, "I only accept Bitcoin payments" and maybe you can start minting some new whole coiners that way. But unfortunately based on your jurisdiction, at the end of the day, whatever you do, even if you're mixing, you may be required to report all that activity. That's the law. There are things you can do to mitigate it, but obviously you need to play by the rules every step of the way.

Ron (42:10):
Another question we have is "In Casa's multisig (this is pertinent to the Casa product itself), which key is the one actually holding the funds? The phone key, the hardware wallet, or the Casa key?" This touches on multi-signature. A lot of the talk content that we gave today deals with single key pairs (individual key pairs), but there's a concept called multi-signature where instead of just needing one private key to move funds, you need two of three or three of five. In that instance no key is really the one that's holding the funds. All of the keys in a multi-signature setup are of equal value. As long as you meet the quorum, they're going to be able to move the funds. If you were able to compromise one key, you wouldn't be able to move those funds. That's the beauty of multi-signature.

Ron (43:00):
"What's the most common misconception when it comes to the public and private keys in Bitcoin?" Do you have one you've heard of Stacie?

Stacie (43:12):
I was thinking about this when I saw it going through the chat. I think a lot of the misconceptions and the confusion come from the fact that an address is not necessarily a public key. Also, if you have a public key, yeah you can generate an address that starts with 1, but you can actually run it through the function and generate a SegWit address, even though you don't know how to use SegWit. I think that's where it gets a little complicated. Also the other misconception -- and it's kind of something I discovered while doing this presentation -- is this presentation and a lot of the public key cryptography in Bitcoin is all about digital signatures. It's not really encryption, but encryption is really cool and we talk about it all the time. I had a whole slide on how Snowden used encryption to communicate with the journalists, but Bitcoin doesn't really use encryption that much. So that's my answer.

Ron (44:16):
I think for me a big misconception, and I think as an industry we need to get better at this, it's the UI and the UX. We use a lot of terminology like keys, and seeds, and mining. The markets are up, so I've had a lot of people coming out of the woodwork asking me about Bitcoin recently. They asked me if there was an e-mine found that was being mined recently. I had to stop for a second and think, well, wait a minute, this person thinking literal mining, that there's a mine of bitcoin on the Internet that people are going to, and finding, and mining. I think we're using terminology and we're using technical terms and cryptography terms that make sense when you start using them and you've been in the industry for a little while, but I think there's still a gap that we need to be better about as an industry if we're going to onboard people and bring them into this ecosystem. They're not going to necessarily understand private-public keys so being able to abstract away from that layer to me helps fix some of those more common misconceptions.

Ron (45:17):
"What is the functional difference between a seed phrase and a private key?" Oh, this is a great question. "Why not just memorize keep track of the private key instead of the seed phrase?" Very easy. So we have to enter these things into different devices, hardware devices. Things break. We need to rotate stuff. We get new phones. Would you rather type in 12 words that you can easily recognize, or would you rather type in a 64 bit or 128 bit string that you could very easily typo or miss a character? With private keys there's a concept of master private and public keys where you can derive 10,000 private keys off a single master private key. What I would say is it's a lot easier to store those seed phrases than to store a real long master private key, or 10,000 individual private keys.

Ron (46:12):
The last question I think we'll take for today, "How do I use the derivation paths?" Do you want to take this, Stacie?

Stacie (46:18):
Yeah. Hopefully the demo that I did with the Ian Coleman website gave you a better idea of exactly how they work. Basically, you're not going to use derivation paths unless you're a wallet developer, but it's really helpful to know what's going on under the hood. If you are a wallet developer, then basically every time you want to generate a new receiving address, you're just going to increment the derivation path and get a new one. If you want to learn more, BIP-32 is the one that you really want to focus on.

Ron (46:51):
The the Bitcoin improvement proposals are great to dive into. They're the start of some of these concepts like Taproot and Schnorr and HD wallets. And some of these other concepts we've mentioned today. Unfortunately we are out of time, you guys have been a great crowd. You've had great questions. We love to continue the conversation. You can find us both on Twitter. Thank you for attending.

Stacie (47:16):
Thank you all. And shout out to all the people asking questions and also helping us answer them. We really appreciate it. Until next time, see ya.

